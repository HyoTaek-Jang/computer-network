아이들이 상대방 집 아이들에게 편지를 쓰는게 어플리케이션 레이어

아이들이 직접 편지를 못보내니까 집의 부모님께 전달함. 트렌스포트 레이어, multiplexing

그 다음 빌이 받으면 아이들에게 배부함 demultiplexing

정보전달을 담당하는 트렌스포트 레이어. 일상에선 아이들이름으로 배부했다면 컴퓨터는 포트넘버로 나눔!

우체통에서 상대방 우체통에 전달하는거. 네트워크 레이어., 집주소는 ip address

우체국에 전송하는 길, 피지컬레이어, 실제로 편지가 분실안되게 우체국으로 전송하는게 데이터링크레이어

우체국끼리 가는건 고속도로로 또 다른 피지컬레이어랑 데이터링크레이어가 있음

피지컬이랑 데이터링크는 같이 구성되어 다님

---

인터페이스는 아래위 관계에서만 가능.

### 트렌스포트레이어와 네트웤 레이어의 관계!!

엔드 시스템 : 어플리케이션 레이어를 갖는 시스템

#### 네트워크 레이어

엔드시스템 간 로지컬 커뮤니케이션을 제공함. 엔드 호스트 시스템에 대해. 인터넷을 통해 연결된

인터넷으로 연결된 네트웤 장치를 통해 어플리케이션을 포함한 엔드시스템간의 패킷전달을 담당

#### 트랜스포트 레이어

로지컬 커뮤니케이션을 제공, 바로위 에플리케이션 프로세스 사이에서, 서로다른 호스트에서, 어플리케이션에서만 관점을 갖고 만든..!

1. SENDER SIDE : 어플리케이션에서 데이터를 받으면 세그먼트라는 단위로 나눠서 네트웤 레이어로 내림.
2. receiver side : 세그먼트를 받아 묶어서 reassemble함. 그리고 어플리케이션 레이어로 올림

트랜스포트 레이어는 프로세스가 돌 때 그 간의 데이터 전달을 담당함

## Transport layer protocol

1. TCP(Transmission Control Protocol)
   등기우편.
   전송을 보장함.
   전달된걸 알려줌.
   커넥션을 기반으로 reliable함.

2. UDP(user datagram protocol)
   손실에 책임을 안짐
   띡 보내면 끝임.
   제대로 갔는지도 모름
   unreliable

### TCP UDP 공통정

멀티플랙싱 디멀티플랙싱( 포트넘버를 통하여 )
error detection(by checksum)

### TCP Only

신뢰성을 주는..! 뒤에서 더 배울거임

# MULTIPLEXING AND DEMULTIPLEXING

멀티플랙싱 : 소스엔드시스템에서 이뤄짐. 어플리케이션 여러 프로토콜이 데이터를 만들어서 트랜스포트로 보냄
얘는 모아서 상대방 호스트까지 보내는 네트웤 레이어에 내림

디멀티플랙싱 : 받는쪽에서! 네트웤에서 받으면 포트넘버를 가지고 어떤 프로토콜에 해당하는지 확인해서 분배함.

## Port Number

32비트로 표현됨.(ip가 32비트 어드레스라)
포트넘버는 16비트로 표현됨 각각 소스포트넘버, 데스티네이션 포트넘버 ㅇㅇ!

포트넘버를 통일하기위해 IANA가 포트넘버 부여하는 룰을 만듬
0~1023 well known (HTTP, DNS, ...이런거)
1024~49151 registered 공공성을 갖는 프로토콜(MY SQL SIP 이런거)
이후는 사용자가 임의로!!
포트넘버는 중복되선 안됨. 하나의 엔드시스템에서 포트넘버는 중복 엑스!

각 앱 프로세스마다 하나씩 포트넘버가 부여됨. 소스랑 데스티네이션.!

포트넘버로만하면 서버가 구분하기 힘들어서 소스 ip랑 소스 포트로 넣음.

<source IP addr>, <source port>, <dest IP addr>, <dest port> 이런 튜플로 만듬.

netstat 명령어 치면
로컬, 리모트 주소, 각각 아이피랑 포트넘버, 상태에는 커넥션이 맺어지고 데이터가 전송되는 상태!!
모든 커넥션이 맺어지면 established

## UDP

네트웤레이어 : 데이터그램 패킷 스위칭을 씀.
패킷들은 독립적으로 갈 길이 정해진다. -> unreliable
상대방까지 가는 길이 정해진게 아니라 connectionless
도착하는 순서가 달라질 수 있음.
이걸 대응하려면 받는 쪽에서 순서를 맞추거나 대체해야함.
TCP는 제공하는데 UDP는 이런게 없음.

네트웤레이어는 언릴라이블함.
udp는 기본적으로 멀티플랙싱이라 디멀티플랙싱만 지원함. 그래서 unreliable한 특징을 그대로 갖고있음.

### udp의 장점

1. low overhead
   헤더가 8바이트로 tcp(20+a)보다 훨씬 작음
2. fast
   커넥션 셋업이 없음

---

그래서 어플리케이션에서 re-ordering이 이뤄짐

UDP는 스트리밍이나 DNS 이런거에서 사용함

헤더에 소스포트넘버, 데스티네이션포트넘버, 랭스, 체크섬임
랭스 : UDP헤더에 udp헤더 + sdu데이터 까지 포함한 바이트단위 길이.
checksum : 받은 udp 세그먼트에 에러가 있는지 확인 (TCP도 있음)

16진수 더하고 오른쪽으로 16비트 쉬프트

그리고 쉬프트한거랑 더한값을 다시 더함. 이땐 앞에 나온거 자름.

마지막으로 one's complement 0->1, 1->0 이렇게!

이렇게 쳌섬 계산하면 tcp랑 udp는 앞에 수도 헤더를 붙임

수도헤더 : 소스 어드레스, 데스티네이션 어드레스, ip 데이터그램 헤더에 프로토콜, udp 랭스

맨처음 쳌섬은 없는부분 넣어야하니까 0을 넣음.

udp 데이터는 16비트 단위로 해야하는데 만약 8비트로 끝나면 0으로 채워줌

그리고 최상단부터 16 비트씩 나열하고 바이너리로 바꿈

그리고 16비트단위로 다 더함. 그리고 오른쪽 16비트 쉬프트해서 캐리부분 만들고
캐리랑 더한 값 더함 -> one's complement -> 이거시 쳌섬!

이거로 어케 에러 디텍션하냐!
보낼때 쳌섬 계산해서 보냄

받는 애는 수도헤더는 데이터그램으로 만듬. 차이점은 쳌섬이 들어있는거 ㅇㅇ
리시버도 16비트로 맞추고. 더해서 캐리 구함. 그리고 또 더해서 나온 값을 one's complement해서 0이면 에러가 없는거임!!!!!!!

에러 쳌섬 만드는거랑 디텍션 검사 방법이 동일함!!

에러가 발생했을땐, udp에서 없애버림 어플리케이션한테 전달도 안함. 말짱한거만 디캡슐레이션해서 데이터부분을 올려줌
