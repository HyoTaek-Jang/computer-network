# DHCP(dynamic host configuration porotocol)

## IP addr 부여하는법

1. 스태틱하게!
   NIC에 접속시키려면, 네트웤 운영자한테 아이피 어드레스를 받아와서 수동적으로 아이피어드레스 설정하는 옵션에서 ip addr, subnet mask, default gateway(내가 만든 패킷을 처음에 접속하는 라우터.)를 설정함.
2. 다이나믹 하게!
   인터페이스 카드에 명시적으로 넣는게 아니라, 다이나믹하게 받는거! DHCP에 의해 자동으로!

DHCP : 어떤 호스트가 네트웤에 조인하려고 할 때 DHCP 서버로부터 내가 사용할 ip addr을 동적으로 가져와서 사용하도록 해주는 프로토콜
IP 어드레스를 네트웤에 접속할때마다 새로 갱신됨. 이러면 addr을 재사용 할 수 있음

최대 수용하는 호스트 컴퓨터 수는 하나의 네트웤 어드레스가 고정되면 호스트 부분에 따라 제한됨. 2^r-2
내가 만약 사용하지 않고 있어도 아이피어드레스를 갖고있으면 사용하지 않는데 아이피어드레스 공간 낭비가 일어남. -> 특정한 NIC에 고정적으로 주지말고 동적으로 재사용하자! DHCP

DHCP 서버에 호스트부분에 대한 2^r-2만큼 ip addr pool을 갖고있고 사용되지 않는 ip를 부여해주고 시간이 지나면 회수하고! 반복!

네트웤디바이스가 새로 부팅해서 자동으로 설정해주는 프로토콜 BOOTP!!

DHCP는 굳이 따로 만들지 않고 BOOTP에 추가해서 만든거. ip addr이 없기에 udp로 접속!

BOOTP 형식과 동일함
여기에 DHCP 형식을 임베드

op(req or reply) htype(hardware type) hlen(hardware address length) hops(hop count)
flags(unicast or broadcast)

dhcp를 만드려면 bootp option부분에 Tag, length, value로 dhcp를 알려줌.

# DHCP 4가지 동작

1. discover (optional)

2. offer (optional)

3. request

4. ack

dhcp가 첨이면 1,2번도 다하고!
ip addr 쓸때 쓸 수 있는 시간이 정해져서 넘어옴.,
만약 시간을 더쓰고 싶으면 dhcp에 요청을 해야함. 이땐 1,2번을 생략하고 리퀘하고 ack을 해서 시간을 연장함.

---

## DHCP Opration

    서버가 하나만 있으면 하나가 망가지면 다 망가지니까 백업이나 동시 서버를 만듬.
    이러다 한 컴퓨터(DHCP client)가 네트웤을 연결하려고 ip addr을 연결하려고 하면.
    1. DHCP discover을 함. udp로 broadcast(255.255.255.255)보냄. 중간 컴퓨터는 서버가 아니니까 무시하고, 두개의 DHCP서버가 받음.
    2. 메시지를 받은 dhcp는 udp, broadcast로 DHCP offer를 보냄. 이 의미는 클라이언트에게 내가 아이피 부여할 수 이씀을 알려줌
    3. 클라는 둘 중 하나를 선택해서 하나의 서버한테 boradcast req를 보냄.
    4. 리퀘 받은 서버가 broadcast ack를 날림.
    5. 클라는 이 시점에서 ip를 부여받아서 네트웤에 접속해서 사용함.

    1. DHCP discover msg : src : 0.0.0.68. dest:255.255.255.255.67
    2. 오퍼 할때 소스는 서버 ip addr, dest는 브로드케스트 어드레스 ㅇㅇ! 포트넘버는 바뀌는거 ㅇㅇ 서버랑 클라를 나타내는..! yiaddr에 오퍼 아이피를 실어보냄
    3. 리퀘를 보냄. 소스는 그대로 두고, 브로드케스트로 dhcp가 보낸 정보를 실어서 보냄
    4. 서버가 ack를 보냄. 이때부터 주어진 ip로 동작함. 라이프타임도 같이 보냄!

    만약 재전송해서 받을땐 브로드케스트나 유니케스트 다 할 수 있음.

## DHCP relay

    dhcp가 제공하는거
    1. ip addr
    2. subnet mask
    3. firtst hop router addr(default gateway) // 첫번째 접속해서 패킷을 보내는 라우터의 어드레스인 디폴트 게이트 웨이
    4. name and ip address of DNS server // DNS  서버에 대한 정보

    dhcp relay
    메세지는 브로드케스트임. 브로드케스트는 하나의 서브넷 내에서 모든 nic에게 전달되고 라우터는 못넘어감. 만약 다른 서브넷에 있는 애가 접속하려고하면 라우터에서 차단되서 dhcp 서버까지 못감.
    그럼 dhcp서버를 모든 라우터에 놔야함. 이러면 서버관리 오버헤드가 생김

    이걸 해결하기 위한 dhcp relay -> 라우터에 이 기능이 부여됨. dhcp 메시지를 차단하지 않고,(포트넘버로 체크). 포워딩테이블로 만들어서 이 메시지가 dhcp서버쪽으로 릴레이 시킴. 서버는 이걸 받아서 브로드 케스트함. 이러면 또 라우터로 와서 릴레이해서 다른 쪽으로 전송해주는거.

---

# NAT(network address translation)

프라이빗 ip addr과 관련된 기능.

퍼블릭 ip addr은 IANA에서 관리해서, 인터넷에 접속하는 모든 NIC이 유일하게 구분되게 하는 기능을 제공.

프라이빗 ip addr은 네트웤에서 프로토콜을 만들고 실험하거나 개인적으로 사용할때 적용되는 addr -> 개인이 설정. IANA에서 관연하지 않음.
인터넷의 보편적인걸 지원하려고 classful ip에서 클래스 a,b,c의 프라이빗 ip addr을 정의함.
프라이빗 ip는 라우터에서 막아서. 퍼블릭 도메인으로 못가게 막음

이런 용도로 쓰다가 ip addr이 부족해짐. 근데 IPv6에 왕창 늘려서 ㄱㅊ긴함. 근데 들어오려면 오래걸려서 새로운 방법을 고안함. NAT!!!!
-> 하나의 퍼블릭 아이피어드레스에 여러 프라이빗 ip addr이 공유하면서 사용하면서 글로벌 인터넷에 접속해서 서로 응용할 수 있는 func
-> 아이피를 빌려주는건가?

NAT을 지원하는건 라우터들!
NAT을 운영하는 라우터들은 테이블을 갖고있음. 왼쪽 프라이빗, 오른쪽 퍼블릭 addr을 관리하는 테이블이 있음!

프라이빗이 퍼블릭 서버에 접속하고 싶다!!! 이러면 src에 프라이빗 아이피, 포트넘버 넣고 dest는 퍼블릭 아이피 포트넘버를 담음
원래같으면 라우터가 차단하는데 NET 기능으로 왼쪽 테이블에 프라이빗 올림. 오른쪽에 자신에 부여된 퍼블릭 아이피를 적음. 그리고 포트는 사용하지 않는 포트 ㅇㅇ. 매핑 관계를 맺음.
퍼블릭으로 갈때 ip헤더를 바꿔줌 라우터가. 소스를 원래 프라이빗 아이피가 아닌 라우터 자기껄 담음. 아까 테이블에 적은거 ㅇㅇ!
이러면 소스 데스티 둘다 퍼블릭이니까!!
서버도 정상적으로 reply하면 라우터가 받아서 또 변화시켜서 프라이빗으로 보내줌

그러면 퍼블릭에서 프라이빗 서버로 접속이 될까?
예아! hole punching! 할 수 있음!

---

# IPv6

ipv4는 아이피어드레스가 32비트가 네트웤 어드레스가 부족한 잠재적 문제가 있음. -> 개선하려고 여러 프로젝트가 있었음. 버전 6가 ip addr 부족한 문제를 해결함. 그래서 현재 IPv6쓰기로 정해짐.
다음부턴 아이피보다 미래인터넷에 관련된 내용으로 진행되기로 함!

ipv4는 소프트웨어적으로 처리해서 느림. 이걸 빨리해보자!
품질도 제한이 있는데 보장을 해보자!
네트웤 접속 개수는 사람을 추월한지 오래임 2006년쯤

## IPv4

addr : 32비트, 10^9
패킷헤더가 변경됨 옵션에 따라. 소프트웨어로 만들어야함.
클래스풀 쓰다가 cidr 쓰고 flat
유니캐스트, 멀티캐스트, 브로드캐스트
TOS! 지금은 지원안함
보안은 아이피랑 시큐리티를 분리함.
ip addr을 부여하는거 매뉴얼하게!

## IPv6

addr : 128비트 10^38
패킷헤더 40바이트 고정. 더 효과적임. 하드웨어적으로 구현가능!
cidr쓰고 hierarchy!
유니캐스트, 멀티캐스트(멀티랑 브로드 합친거), anycast
트래픽 클래스, 플로우 레이블로 품질 관리
IPSec을 반드시 같이써서 보안을 필수로 집어넣음
ip addr을 부여하는거 자동화!!

---

### IPv6 Address

128비트 사용! 헥사데시말! 사이사이를 :으로!
버전 4는 42억! 버전6는 걍 무한대임..

### address type

- uincast(1ㄷ1 양방향)
- multicast(1ㄷn 단방향)
- anycast(1ㄷnearest one, 양방향)
  DNS에서 사용함. 서버를 여러군데 놓음.
  클라는 서버 중 하나에 접속하면 됨.
  라우터나 네트웤에 있는 서버가 특별한 기능을 DNS하는 서버는 well known addr을 갖고있음.
  이 어드레스 하나에 여러 서버가 있음. 클라가 요청을 보내면 가장 적합한 서버 하나를 선정해서 포워딩함. 서버가 클라에 대한 응답을 하면서 서로 정보 교환함. 이거시 ANY CAST
  프록시랑 비슷한데. 다름. 프록시는 오리지널 서버랑 교환하는거고. 애니케스트는 서버를 독립적으로 하면서 서로 정보를 동기화하는 메카니즘은 따로 있음. 그리고 그 중 클라랑 적합한 놈을 알려주는..!

### IPv6 Address Scope

    메세지가 전달할 수 있는 범위를
    Link-local : 하나의 라우터에서 나온 서브넷에서만 가능
    site-local : 기관 내!
    global : ㅇㅇ!

    메시지의 한계를 냅둠. 흘러다니는 패킷의 수를 조절함.

### Unicast Address

    IANA이가 부여함.
    근데 계층이 있음.

    FP TLA(탑레벨) RES NLA(넥스트레벨) SLA(사이트레벨) 여기까지 네트웤 포션
    우리나라 전화번호로 따지면, +82 : 탑레벨, 031 넥스트레벨, 219 사이트레벨
    나머지 64비트 호스트 포션

    Auto-Configuration!
    데이터링크 레이어에서 사용하는 어드레스는 MAC address ! 48비트. 이것도 유니크함.
    이거 그대로 48비트 넣고 나머지도 그냥 채우느거로! 그래서 걍 내가 갖고있는거로 만들 수 있음. dhcp도 필요없음

### Datagram Format

    base header - 40바이트 고정!
    extension header는 추가적으로 뒤에 붙이는 형식!

    구조는 강의노트 참고!

    payload length는 ip 데이터그램 헤더 길이! 40바이트 기본헤더를 뺀 나머지!!

    버전 4랑 비교해서 달라지는건 옵션떄문에 헤더랭스가 있는데 버전 6는 헤더랭스가 없음 옵션이 없음. 데이터그램 랭스는 버전 4는 전분데, 6에선 헤더뺀 나머지 ㅇㅇ!
    넥스트헤더는 버전 4에서 어퍼레이어프로토콜의 기능이랑 옵션에 대한 기능을 포함하는 거!
    hop limit은 TTL이랑 ㅇㅇ!

#### next header

    포트넘버 느낌인가.
    넥스트헤더 0 : hop by hop
    이러면 data부분에 next hdr=43, hdr length 익스텐션 헤더 길이
    또 다음엔 43에 대한 next hdr! hdr length
    계속 이렇게 반복 이러다! 6가되면 TCP니까 이제 TCP SDU가 나옴.
    하드웨어로 구현되면서 빠름!

flag days!!! 딱 바뀌는날. 근데 네트웤은 딱 바꾸는건 불가능해..
조금씩 오버랩하는거쥥

서서히 공존하면서 바뀌는 방법!!

1. dual stack
   라우터에 v4 v6 둘다 넣다가 필요한거로 바꿔주는! 근데 6에서 4는 뺴면되는데 4에서 6은 더 넣어줘야함. 그래서 사라지는 정보가 생겨서 v6의 기능을 못쓰기도 함.
2. tunneling
   v6 -> v4로 갈때, 바꾸는게 아니라, SUD처럼 그대로 놓고 헤더로 ipv4를 덧붙임. 그러다 v6가면 헤더부분 버리고 ㅇㅇ! 이러면 라우터들이 이런 기능을 갖춰야하니까 라우터가 비싸지고 프로토콜이 더 필요함.
3. header translation

현재 v6를 25퍼정도 사용함.
v6의 장점은 어드레스 공간인데 충분히 기존 기술로도 잘써서 안넘어가기도 함...ㅋㅎ
