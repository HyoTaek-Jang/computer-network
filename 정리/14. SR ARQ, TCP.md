# GBN 단점

하나가 잘못되면 뒤에 모든걸 다시보내야함

# 그걸 극복하는 Selective Repeat ARQ (SR)

positive ack 사용
window 메카니즘 사용

## SR sender

모든 보낸 ack를 받지 않은 패킷들에 타이머 구동
타이머가 끝나면, 타임아웃 발생한 놈들만 재전송

app layer에서 데이터가 내려오면 시퀀스 넘버를 붙이고, 윈도우 안에 속하면 전송함
그리고 타임아웃되면 패킷을를 재전송함. 그리고 타이머 재구동
ack를 받으면 채우고, 윈도우 맨앞이면 윈도우 슬라이딩까지!

## SR Receiver

모든 정상 수신 패킷에 대해 개별적으로 ack날림
GBN는 버퍼를 안써서 순서가 다르면 discard함
SR는 버퍼를 사용해서 순서가 뒤바뀌면 버퍼에 저장해서 채워가는 방법

윈도우 내에 있는 패킷을 받으면 다 개별적으로 ack
순서가 뒤바껴서 오면 일단 ack 보내고, 버퍼에 집어넣음
그리고 순서가 채워지면 윈도우 슬라이딩

이미 도착한게 또 오면!?(리시버가 보냈는데 손실된겨!) 다시 ack보내줌! 센더가 알아야하니까

위의 경우 외는 다 무시함

메모리카피 문제 발생. -> 처리 속도가 느려짐. -> 통신은 패킷이 빨리 왔다가야하는데 타이머도 쓰고 하면 너무 복잡하고 느려짐. 그래서 좋긴한데 엔지니어링 측면에서 ARQ를 GBN을 선택함.

---

타이머가 비싼 리소스임. 제한되고 필요한 곳에서 쓰임
우리가 가장 많이 쓰는건 GBN임

SR에 cumulative 넣으면? 가능하다~ 이러면 센더는 바로 바뀌지 않고 ㅇㅇ!
상황을 디테일하게 알 수 없는 문제... SR 특징을 최대한 활용하려면 모든 패킷에 ack 날리는게 효과적!!

TCP에서 GBN을 사용함!!
버전업하면서 불필요한 재전송을 막는 방법을 적용해서 사용함
