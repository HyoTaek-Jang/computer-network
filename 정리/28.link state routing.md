# network layer : control plane

## routing

네트웤레이어의 주요 기능

1. 라우팅 : 컨트롤 플레인 : 네트웤 정보를 구해서 라우팅 알고리즘 적용 -> 라우팅 테이블 제작 -> 이거에 근거해서 도착한 패킷의 dst를 보고 ip를 확인해서 다음 라우터로 전달
2. 포워딩

---

각 라우터는 독립적으로 라우팅 프로토콜이 동작함.
각 프로토콜은 서로 정보를 주고 받으면 네트웤에 대한 정보를 구함. 구해신 정보를 topology database라고 함
db를 갖고 라우팅 알고리즘이 동작해서 결과로 만들어진 routing table

이건 모든 라우터에서 독립적으로 만들어짐.

### 라우팅 알고리즘 2가지

알고리즘을 동작시키려면 정보가 필요함.

1. global routing algo
   필요한 정보가 네트웤 전체에 대한 정보
   Link stage algorithm

2. decentralized algo
   전체가 아닌 로컬을 기반으로 각자 라우터들이 협력에 의해 라우팅 테이블이 만들어지는!
   distance vector algorithm

라우팅 테이블 한번 만들고 계속 쓰는 static routing algo
변하는 네트웤 상황에 맞춰서 라우팅 알고리즘을 업데이트 하는 다이나믹 라우팅 알고리즘

우리가 배울 두 가지 라우팅 알고리즘은 다이나믹!!!

---

# Link state routing algorithm

abstract graph model
여러 장치들이 라우터들을 연결해주는 링크로 연결됨. 네트웤을 표현하는 첫번째 그래프!
G = (N,E) N은 라우터 셋, E는 링크 셋

네트웤을 컨트롤하려고 네트웤 상황을 반영하는 요소가 cost!

코스트는 각 링크에 부여된 값! c(x,y)로 표현
(노드가 직접 연결이 아닐때)여러 링크를 거칠 수록 합으로 표현됨. ㅇㅇ!

## LS algorithm

동작하려고 네트웤에 모든 정보를 가져와야함. 글로벌 라우팅 알고리즘 범주

어떤 노드(소스)로 부터 다른 모든 노드로 가는 최소의 패스를 찾아라!
그 결과로 나온게 소스 노드로 부터 다른 모든 노드로 가는 라우팅, 포워딩 테이블!

어떤 소스로 부터 dst까지 갈때 현재 단계에 있는 노드까지의 코스트 D(v)
v노드 직전 노드 -> p(v)
N' : N은 전체 네트웤 노드 집합. 패쓰 만드는 과정에서 찾아 놓은 노드의 집합. 이게 N이랑 같으면 알고리즘 종료

---

수도코드 확인
거쳐가는거랑 직접 가는거 중 코스트 낮은걸 선택. 이과정을 모든 연결된 링크에 대해 확인

코스트는 보통 링크스피드의 역수를 취함.

매순간 젤 작은놈을 기준으로 바꿈.

걍 그래프 알고리즘이랑 똑같네 ㅇㅇ-!

값같으면 암거나 고르고

---

포워딩 테이블 만드는것도 피피티 참고!! 포워딩 테이블은 바로 다음 라우터 위치를 안내함. 링크로 ㅇ!

---

### ls algorithm - complexity. 시간복잡도 계산

1. 모든 노드 계산 n 초기값
2. 최소값을 갖는 노드를 빼고 하니까 n-1!
3. n-2.
   ... = (n^2+n)\*1/2
   O(n^2)

---

LS가 동작하려면 노드가 다른 노드의 네트웤과 관련된 정보를 다 받아야함.
어케하누!

### LS infromation Flooding

각 노드는 인접 노드와 정보를 주고 받음. 누구랑 연결되있고 패스가 몇이다 (link state info)
flooding이라는 기법으로 모든 노드에 정보를 다 전달함.

#### Flooding

하나의 노드가 있을때 노드는 자기가 보낼 패킷을 연결된 모든 노드에 보냄
받은 노드는 그걸 또 다른 노드에 다 보냄. 패킷을 들어온쪽은 제외!
결과적으로 모든 노드로 전달이 됨(여러 카피가 되긴 함)
그래서 TTL, hop count를 지정함. 3으로! 무한정 패킷 전달을 막음

이거로 결국 모든 노드들은 link state database를 가짐

---

연관된거를 트리로 만들고 최소 코스트를 고름
그림보면 이해함 ㅇㅇ 알고리즘이랑 상당히 유사함
