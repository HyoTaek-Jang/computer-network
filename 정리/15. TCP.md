TCP는 ARQ 메카니즘을 사용함.
타임아웃을 개선해야함

TCP : Connection oriented임.
전화같은 경우 connection oriented라고 함. 전화는 circuit establishment
통화하는 과정 data transfer
전화 끊으면 circuit disconnect
통신하는 상대방을 위해서만 사용되도록 만들어짐. -> dedicated - ack를 사용하지 않음

서킷스위칭은 데디케이트한 커뮤니케이션 패스를 만들어서 다른 상대방이 침해하지 못함.

한번 연결되면 모든 전달되는건 바로 보내짐. 딜레이없고 손실도 없음!!!!!!

전화망은 음성에 특화된 네트웤!

---

우리의 인터넷은 데이터그램 패킷 스위칭
모든 정보를 패킷으로 쪼개서 보내고, 라우터를 통해 보내짐
라우터는 모든 패킷을 독립적으로 처리함. 손실될 수도 이씀!
하나의 선을 여러 커넥션이 같이 사용함

패킷이 한곳에 몰리면 패킷 딜레이가 생기고 손실이 생길 수 잇음. congestion

이런걸 connectionless라고 함.

# 커넥션 오리엔티드

1. 두 호스트 간 실질적인 커넥션을 맺고 데이터를 보내는 방법 ack 미사용
2. TCP는 ack를 사용함. 데이터 그램 패킷 스위칭. 피지컬 커넥션을 안맺음.

## 커넥션 오리엔티드의 정의

센더의 입장에서 어떤 메시지를 보내면 이 메시지가 리시버한테 정확히 전달됨을 센더가 확실히 하는 상황을 제공되는것
(전화선은 피지컬로 연결이 되있고, TCP ack를 통해 알 수 있음.)

이게 아니면 커넥션리스

---

# TCP

TCP는 커넥션 오리엔티드
3 phases

1. connection establishment
2. data transfer
3. connection termination

물리적은 커넥션은 아니고 positive ack machanism으로 !
ARQ는 (샌더 리시버)1:1 관계임. POINT TO POINT
센더가 1이고 리시버가 여럿이면 일방으로 보내는 UDP를 사용
full duplex : 양방향(보내면서 받을 수 있음. 하프는 양방향인데 같이 보내고 받진 못함.)
pipelined : GBN ARQ랑 비슷한거 사용하고, SR과 같이 리트렌스미션에서 타임아웃된것만 보내는 하이브리드 방법을 사용
flow controller :

# Transport layer

공통적으로 포트 너버를 통해 어플리케이션을 구분. 멀티플랙싱과 디멀티플랙싱
에러딕텍션을 위한 쳌섬 기능!

## tcp ONLY

1. segmentation : 자른다. 큰 파일을 자르는거! 어플리케이션에서 그대로 내림. 근데 NIC에서 보낼때 자기가 처리할 수 있는 프레임의 사이즈가 한정(MTU maximum transmission unit)되있음. 그래서 쪼개줘야함 -> 최대로 자를 수 있는 사이즈가 있음. MSS(maximum segment size)!! 이거에 시퀀스 넘버 붙여서 밑에 레이어로 보냄

2. 센더는 자르기만하고 한비트도 안건들임. encapsulation 그대로 유지!

3. 리시버는 센더가 시퀀스 넘버를 붙여놔서 그걸 보고 원래 순서대로 맞춰서(reassembly) 어플리케이션으로 올려줌

---

udp는 이런 새그먼테이션 리어셈블리가 없음. 그래서 어플리케이션에서 데이터 만들면 반드시 MTU사이즈를 고려해서 하나의 UDP 세그먼트에 모든 데이터가 다 있는 형식으로 해야함. 만약에 너무 크면 어플리케이션에서 나눠서 줘야함!

MSS : 어플리케이션에서 내려온 데이터를 세그먼트로 만들때 최대의 크기!
하나의 TCP 세그먼트 = TCP 헤더 + 세그먼트 데이터
MSS = MTU - (TCP & IP 헤더 랭스)

MTU는 ip(20 바이트)레이어(20 바이트)부터 tcp, 데이터까지! 네트웤 인터페이스 카드가 처리할 수 있는 최대 크기

### TCP segment structure

소스 포트 넘버, 데스티네이션 포트 넘버, 시퀀스 넘버, ack 넘버
udp는 전체 데이터 랭스는 있는데 헤더 랭스는 없음. tcp는 헤더랭스(32비트 단위로! 5면 20바이트)에 옵션이 들어갈 수 있는데(대부분 없음) 헤더가 가변적임. 그래서 길이를 알려줘야함.
쳌섬, 리시브 윈도우(flow control할때!)
urg, ack, psh, rst,syn,fin
urgent data pointer 거의 안씀

### 시퀀스 and ack num

세그먼트의 첫번째 바이트 스트림이 시퀀스 넘버임! 잘라진 일련번호가 아님 어플리케이션 데이터의 바이트 스트림 넘버를 부여했을때 세그먼트의 첫번째 숫자

다음에 받을 시퀀스 넘버를 ack 넘버에 넣음 -> cumulative ACK
ack 넘버를 세팅하고 ack flag로 1로 세팅하면 ack 넘버가 의미가 있음을 의미함.

piggybacking
두개의 정보를 하나의 패킷에 실어서 보내는거!
내가 보낼때 받은걸 같이 담아서(시퀀스 넘버랑 ack 넘버) 보낸다!
시퀀스+1이 ack가 되고 ack가 시퀀스가 되는..!
