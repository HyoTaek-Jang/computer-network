# SDN이 나오게 된 배경

라우터내 모든 기능이 포함되서 동작하는, 라우터가 다른 라우터와 독립적으로 기능을 수행하는 per router 기반의 control plane을 가짐.
모든 라우터에 라우팅 프로토콜이 있어서 네트웤 정보를 주고 받고, 라우팅 알고를 주고받으면서 모든 라우터들은 독립적으로 라우팅 테이블을 만듬.
패킷이 도착하면, 헤더에 있는 dst ip로 라우터를 서치하고 엔트리를 찾아서 포워딩!!

동일한 동작이 독립적으로!!

라우팅 테이블이 만들어지는 control plane
만들어진 테이블로 패킷을 다음 라우터로 포워팅하는 data plane

인터넷에게 패킷이 전달되는 과정은 next hop routing 방법을 취함.
네트웤에 대해 토폴로지 정보를 구해서 라우팅 알고가 동작해서 라우팅 테이블이 독립적으로 네트웤마다 만들어지면, 만들어진 라우팅 테이블은 목적지까지 가는 end to end path가 아니라
바로 다음에 있는 라우터 정보만 라우팅 테이블에 반영해서 포워딩하는 과정은 라우팅 테이블을 네트웤 레이어에서 묵업해서 지정된 인터페이스로 보내고 ㅇ!
계속 다음 라우터로만 보내는거임 같은 작업을 통해

컨트롤 플레인은 라우팅 작업을 반복하고,
데이터 플레인은 포워딩이 하고!

라우터에 동작하는 하드웨어랑 소프트웨어가 한 장비에 타이트하게 연결되서 동작함
이 모든게 라우터 장비를 만드는 제조업자에 종속되는 관계가 생김.

라우터에 들어가는 기능을 보면, 하드웨어 장비가 있고, 그걸 동작시키는 app이 있음. 그게 돌아가려면 운체가 있어야함. 네트웤이 동작하는 라우팅 이런 app은 os위에서 돌아가고 그 영역을 control plane

그렇게 만들어진 라우팅 테이블에 따라 하드웨어는 그냥 포워딩만 함! data plane

기능이 추가될때마다 메모리가 꽉참.. 좋은 네트웤 프로토콜이 만들어졌는데 메모리가 없네!? 그럼 장비를 바꿔!? 바꾸면 다 바꿔야해...

라우터를 보니까 컨트롤이랑 데이터부분의 작업은 분리되있는데 장비에 같이 있음
그래서 쪼개보자!!!! 아에 네트웤을 통해 완전히 분리하자!!!! 그래서 나온게

# SDN(software defined networking)!

네트워킹 : 컨셉. 기술적인 포괄적 의미
네트웤 : 라우터로 구성되있는 물리적 의미. 오브젝트

snd : 컨트롤 플랜, 데이터 플랜을 디커플하는 개념!
분리가 되면 snd 용어를 쓸 수 있음.

포워딩 플레인은 모든 app이랑 서비스를 수용할 수 있는 구조로 만들어져야함.
포워딩 장비를 SDN switch라고 불리며 포워딩만하고

라우팅테이블을 만드는 장비를 SDN Controller, 여기에 라우팅 매니지먼트 기능을 management plane에 넣고 필요한걸 취사 선택하면서 네트웤을 메모리의 제한이나 밴더의 종속을 없앰.

5G에도 SDN이 들어감! CUPS(control user planes separation)

특정 라우터를 개별적으로 선택하며 오동작을 막고. 전체 네트웤의 관점에서 트래픽을 흘리니까 flexibility가 강해지고!
기능을 프로그래밍되게 만드니까 원하는 기능을 만들어서 네트웤 운영이 됨

switch는 테이블에 따라 포워딩만 하니까 컨트롤러가 프로그램으로 다양한 방법으로 만들면 됨~ 아 ! 융통성 있다!
특정 벤더에 종속되지 않는 오픈된!!

포워딩 플레인에서 generalized 포워딩을 지원함. 지금까지 봤던 라우팅 알고는 네트웤 레이어에서 작동하니까 ip addr만 필요했는데, 포워딩할땐, mac addr, ip addr, port num,...etc를 고려해서 다음 라우터로 넘김. 레이어에 국한되지 않은 포워딩을 지원함 제너럴라이즈드!

---

컨트롤러랑 스위치 간 커뮤니케이션을 담당하는 southbound APIs(vendor-nertural)
컨트롤러랑 매니지먼트 플레이인랑 소통하는 northbound apis(network abstraction)

---

### SDN DATA PLANE - generalized forwarding

SDN은 메카니즘이 아니라 컨셉임.
구현에 다양한 방식이 있을 수 있음.
핵심은 sdn 컨트롤러! : 스위치가 포워딩할 수 있는 방법(테이블)을 만들어주는 요소!

### 사우쓰바운드 api의 대표적인 OpenFlow

컨트롤러랑 스위치간에 커뮤니케이션을 제공하는 인터페이스(프로토콜)
TCP를 사용. 옵셔널하게 encryption 할 수 있음.
오픈플로우에서 적용되는 메시지는 컨트롤러 <-> 스위치
컨트롤러에서 스위치로 가는 메시지는 대부분 싱크로너스함
스위치에서 컨트롤러는 자기 상황에 맞춰서 보내기에 async

### SDN 데이터플레인에서 포워딩 룰 : generalized forwarding

오픈플로우는 패킷의 교환을 플로우라고 표현함
플로우에 맞춰서 패킷을 전달하는 테이블을 라우팅 테이블(플로우 테이블)이라고 함.
라우팅 테이블은 네트웤 레이어에서 동작하기에 ip만 사용하는데, sdn 데이터 플레인은 모든 레이어를 포괄적으로 적용해서 flow table이라는 다른 표현을 씀.

룰에 대한 정보를 갖고 액션을 취함

1. 플로우와 매칭되는게 있으면 포워딩!
2. 컨트롤러에 보낸다!
3. 드랍!
4. 파이프라이닝!
5. 필드를 바꾼다!
   ...

플로우 정보에 따라 액션을 알아서 하게!! 기존 같으면 기능을 각각 뒀을텐데 sdn은 하나의 플로우를 활용해서 매치해서 ㅇㅇ!

wildcard '\*'도 사용함!!
예시 확인!!

패킷이 스위치에 도착하면
헤더 필드랑 플로우 테이블 엔트리 비교!
매치되면 액션에 따라서 ㅇㅇ!
매치가 안되면 일반 인터넷은 default 루트로 보내거나, drop시킴. 근데 SDN은 컨트롤러에 전달시킴
컨트롤러가 정보를 받아서 포워딩 디시전을 만듬. 그걸 스위치들한테 뿌림 새로운 룰을. 그거에 따라 포워딩됨.

데이터 포워딩 예제 확인

---

# SDN Control Plane

1. 전통적인 라우팅 방식에선 로드 밸런싱이 가능할까?
   RIP는 한 경로만 쓰니까 불가!
   OSPF 여러 경로는 가능한데 코스트가 동일해야함!!
   내가 아예 원하는대로 하는거는 어렵다!
2. 동일한 dest인데 다르게 보내고 싶다!
   next hop을 데스티네이션으로 감! 불가능!!

컨트롤러의 3가지 기능

1. 스위치와 커뮤니케이션, 커뮤니케이션 레이어: 오픈 플로우, SNMP, 사우스바운드 api
2. 매니지먼트를 운용하기위한 정보들. 매니지먼트 레이어 :통계 호스트 정보, 플로우 테이블, 스위치 정보
3. 라우팅, 시큐리티, 품질관리...등등 기능을 적용할때 사용하기 위한 인터페이스 레이어 ! 노스바운드 api

SDN 컨트롤러가 네트웤에 대한 정보를 반영해서 어떻게 제어하는가!?
스위치로 포워딩이 이뤄짐! 근데 링크에 문제가 생겨서 패킷 포워딩이 안된다! 스위치가 상황을 알게되고 오픈 플로우를 거쳐서 컨트롤러에 알림
이 정보는 link state info에 업데이트 됨. 변화가 생겼기에 어떤 어플리케이션이 관련됐는지 찾아서 노스바운드api로 라우팅 알고리즘을 거쳐서 링크 스테이트가 변경됨을 프로그램에 알림.
하튼 링크스테이트 인포랑 상호작용하면서 새로운 플로우 테이블이 만들어짐.
그 변화에 관련된 스위치한테 알려줌!

새로운 라우팅 테이블이 만들어지는 동안 패킷 로스가 일어날 수 있음. 그래서 미리 백업루트를 만들자!
워킹 루트랑 백업루트를 라우터에게 알림
