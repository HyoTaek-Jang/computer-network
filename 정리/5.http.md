# HTTP

- web page
  브라우저에서 주소를 치면 나오는 화면
  여기엔 여러 오브젝트가 있음

- object
  메뉴, 이미지, 글자 등등
  오브젝트를 어떻게 배열할지 - html

- URL(uniform resource locator)
  오브젝트를 가져올때 어딘가에서 html, 오디오 이미지 등등이 저장된 위치 URL
  URL은 host name과 path name으로 나뉨.

## HTTP

    hyper text transfer protocol
    어플리케이션 레이어 프로토콜에서 동작
    클라이언트 서버 모델임
    서버(웹 서버)의 모든 정보가 있고 클라(브라우저)는 브라우저를 통해 서버의 정보를 구해오는 역할

    클라가 HTTP request를 서버에 보냄. 서버는 이 내용을 해석하고 response에 담아서 클라에 보냄
    클라끼리 직접 커뮤니케이션은 안됨

    점점 http를 사람들이 많이씀 그래서 공식적으로 사람들이 참고해서 개발하게 문서를 만듬(RFC)
    RFC : req for commnet

92-95년에 서서히 http가 상용화됨
그 전에는 gopher을 사용해서 ftp를 로그인해서 디렉토리 뒤져서 파일을 가져옴. 그리고 어플리케이션 활용해서 읽음
이후엔 브라우저가 생겨서 복잡한 과정이 사라짐.

인터넷은 http 웹서비스를 통해 엄청난 발전이 됨

http는 TCP에서 돌아감
http : 어플리케이션 레이어 (문서를 전달해야함. 그래서 한비트도 오류가 생기면 안됨. 그래서 tcp사용)
tcp : 트랜스포트 레이어

tcp는 어플리케이션 데이터를 보낼때 클라랑 서버 간 3개의 세그먼트를 주고 받으면서 커넥션을 만들고 데이터 전공이 일어남. 그리고 커넥션을 끊어줌.

### HTTP Coneections = semantics of protocol

### non-persistent http

    TCP 커넥션이 유지된 상태에서 어떻게 유지하느냐!?
    웹페이지는 여러 오브젝트가 있고 그걸 HTML 파일로 배열이 됨.
    오브젝트를 다 가져와야하는데 이건 오브젝트마다 TCP 커넥션을 각각 맺음(HTTP/1.0)

    커넥션 만들고 오브젝트 받고 끊고 다시 커넥션하고 ㅇㅇ 반복

### persistent http

    1번 커넥션 맺고 커넥션 상에서 오브젝트를 여러개 가져옴(HTTP/1.1, HTTP/2에서 사용)
    연결하고 오브젝트 요청을 동시에 우다다다 보내면 응답이 우다다다옴 그리고 커넥션 끊음

RTT(round trip time) : 메시지를 보내고 응답을 받을때까지 시간.

non-persistent http : 커넥션 연결할때 1번, 데이터 주고받을때 1번! + 파일 전송받는 시간 = 2\*RTT + file transmission time : 근데 html 파일을 먼저 가져오고 오브젝트 파일을 가져와야함. 즉 (N+1)\*(2RTT+f)

persistent http : 연결, html, 오브젝트들 ! 총 3번(2RTT+f)

### HTTP Message = syntax of protocol

### HTTP Request

    request line : 어떤 동작을 원하냐! method sp URL sp version cr lf
    sp는 분리의 의미 cr lf은 cr은 커서 한줄 내리기, lf은 첫 시작 지점으로 옮기기 lf

    header lines : header fileid name: sp value cr lf 반복!! 그러다 cr lf 두번나오면 body부분임

### methods

    GET, POST, PUT(전체수정), DELETE, PATCH(일부수정)

### HTTP Response

    status line : version sp status code sp pharse cr lf

    header lines 는 동일 그다음 바디도 동일

### RESTful API

    http 모든걸 다 넣으면 덩치가 커지고 복잡해짐 그래서 고유한 기능만 사용해서 간단하게 만드는거
    http기반 restful

### HTTP request msg

GET /index.htnl HTTP/1.1\r\n
HOST: www-net.cs.umass.edu\r\n
.
.
. 이런식

### classes of HTTP status code

1xx : 진행중
2xx : 정상적으로 진행됨 200 ok
3xx : 페이지 이동 r01 moved permanently. 성공을 하지만 다른애를 통해서!
4xx : 보내는쪽에서 에러 404 not found 클라가 없는 주소로 요청 보낸거지!
5xx : 받는쪽에서 에러 505 HTTP Version not supported 내 서버가 오래되서 지원을 못함... 쏴리

6xx, 7xx도 필요하면 만들 수 이씀

근데 유저에이전트가 달라서 시큐리티 문제가 생길 수 있음.
리스폰스에 서버의 버전이 있기에 제대로 보안을 신경안쓰면 문제가 생길 수 있음
그래서 항상 업데이트 잘해야함

### 성능을 높이는 방법

- 클라이언트와 서버의 상호작용에 의한 응답속도 높이기 : Cookie
  http는 stateless 상태가 없음. 서버는 기록을 남기지 않고 리퀘 받으면 리스폰스 돌려주면 끝임 동작에 대한 상태가 없음
  스테이트를 관리하는건 너무 복잡함 클라가 리퀘하면 서버가 스테이트를 관리하고 동작을 디비를 통해 관리를 해야함. 많은 클라에 대해 모든 스테이트를 관리하면 시스템이 복잡해짐
  근데 RTT가 네트워크가 안좋으면 응답시간이 느려짐. 그래서 cookie를 넣음

### cookie

    데이터의 작은 조각 : 자신이 걸어온 상태를 기억하게끔
    인터넷은 마녀의 숲..!
    먼저 response로 Set-Cookie하고 사용할땐 req에다가 Cookie 보내면 됨
    state를 keeping하고 싶어서!!
    쿠키 저장할때 id를 만들고 그 id를 체크하면서 정보를 제공함. 즉 중복된 과정을 제거하게 도와줌

    쿠키는 인증, 쇼핑, 추천 이러한 곳에 사용이 가능함. 쿠키정보에 대한 보안도 아주 중요함. 서버에서 쿠키 넘버로 동작할 수 있으니까

- 서버 측면에서 어떻게 고려해서 성능을 높일 방법 : Proxy server(Web Cache)
  proxy server : 간첩. 두 당사자 사이에서 한쪽의 정보를 받아서 활용하는거.
  클라랑 원래 서버 사이에서 대행해줌
  클라가 프록시 서버에 요청하고 프록시는 정보가 없으면 본 서버에 요청해서 받고 프록시가 다시 클라에 정보를 줌
  근데 만약 또 동일한 리퀘를 보내면 정보를 갖고있어서 오리진 서버에 안가고 바로 응답해줌
  굉장히 많은 사람이 접속하면 서버가 부하가 생길 수 있음. 구글같이 세계적으로 사용하는 서버일때. 그걸 효과적으로 쓰기위해서 각각 지역마다 프록시 서버를 두면서 보다 효과적으로! 서버 하나의 부담을 나누는거지.
  굉장힌 큰 서버에 성능을 높이기 위해 중간에 대행해주는 서버 (프록시 서버)
  프록시서버가 리스폰스해줌

  시스템 모델을 통해 나의 의견을 제시하는 방법이 될 수 있음.

프록시를 주장하면 왜 프록시가 좋은지 주장할 수 있어야함.
ex) 아주대는 내부에서 빠른데 외부에 나갈때 게이트를 통해 나감. 1.54mbps 라인을 타고 나감. 그리고 서버는 그렇게 밖에 있음.
이럴때 서버에서 가져오는 오브젝트 평균사이즈 100k bits
브라우저가 서버한테 접속하는 레이트는 15/sec
평균 외부망이 1.5mbp
서버 갔다오는시간 2초

이럴때 서버에서 정보를 가져다쓰는 토탈 딜레이가 어떤가..

하튼 해결법

1. access link를 늘림.
   비용대비 효과를 산출함.
2. 로컬 웹 캐쉬. 즉 프록시 서버를 둠

뭐가 효과적인지 봐야함

프록시서버는 ISP(internet service provider)들이 포탈, 회사, 학교에서 프록시 서버를 응요함

클라의 리스폰스 타임이 줌
중앙서버까지 가는 트래픽이 줌. 중앙을 통과하는 속도가 빨라짐

- 클라 측면에서 : conditional-GET
  정보를 받고 내부적으로 캐시를 하는거. 요청을 할때 리퀘 메시지에 언제 받아놨는지 보내줌.
  그리고 서버는 그 날짜에서 변경된거 없어! 라고 알려주고 클라는 자기 로컬에 있는걸 사용함.
  긍까 업데이트가 됬는지를 확인하면서 로컬 작업을 쓰는거지 pull느낌인가
  304 not modified

  200 ok로 데이터 넘어오면 새로운 정보를 받는거임. 항상 오브젝트를 받는게 아님!

### Security concerns on HTTP

HTTP는 아스키 텍스트라 누구든 이해할 수 있음.

### 프라이버시

### integrity

왜곡이 있으면 안됨

### authentication

이 측면도 봐야함

이걸 해겨랗려고 HTTPS가 나옴 http secure
http는 tcp랑 통신하면서 아스키로 텍스트로 나왔는데
http에서 tcp 사이에 TLS/SSL 이라는 암호화 프로토콜이 들어감.
요즘은 대부분 TLS를 사용함

방법
일단 tcp 커넥션 맺고

1. 클라랑 서버에서 정보를 주고 받아서 authentication하고
2. 서로 암호화 방법을 주고 받아서 암호화 키를 공유함. 2번 왔다갔다함.
   그리고 데이터 송신

데이터는 암호화된 TSL를 거쳐 ㅇㅇ 그런 데이터가 가고 리시버는 TLS과정으로 다시 인증을해서 메시지 확인함

이러면 중간에 정보를 탈취해도 TSL 과정을 거쳐야해서 보안이 좋아짐.

이걸 쓰려면 서버가 TLS를 지원하고 클라가 지원해야함. 예전 서버는 지원안했음.
http 포트는 80, https는 443을 사용함
