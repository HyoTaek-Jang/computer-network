# TCP Flow Control

클라랑 서버는 어플리케이션단에서 소켓으로 넷트웤 통신을 함.
OS단에 여러개가 있는데 그중 버퍼를 살펴보자

하나의 컴퓨터에서 전송 데이터를 여러개로 버퍼에 넣어서 보내기도 함.(센더쪽)
그러면 앞에서부터 뽑아서 전송함.

상대방도 받아서 바로 처리가 안되면 버퍼에 넣어서 보관함.(리시버쪽)
OS는 시간이되면 버퍼 앞에서 뽑아서 어플리케이션에 전달

TCP특징 full duplex

## Flow control

센더는 자기가 만들어진 세그먼트를 전송하면, 받는쪽의 리시버 버퍼의 상태를모름(얼마나 차있는지)
얼마나 더 보낼 수 있을지?
리시버의 버퍼가 꽉 찬 경우에서 전송이되면 들어갈 룸이 없어서 정상적으로 도착해도 세그먼트를 버릴 수 밖에 없을 수 있음. -> overflow
버퍼도 메모리라 한정됨

flow control : 버퍼의 정보를 전달하여 오버플로우를 막는거, 센더가 보내는 양과 리시버가 처리하는 양을 잘 조절함

TCP receive window : flow control를 위해 사용하는 필드. 리시버 버퍼의 상태를 ack할때 리시브 윈도우에 정보를 실어서 보냄. 센더는 수신한 리시브 윈도우 상태를 판단함. 리시버 윈도우 사이즈(rwnd)

### receiver buffer

네트웤 프로그래밍에서 소켓을 사용할때 소켓 옵션을 통해 리시버 버퍼 사이즈 결정 가능. 디폴트 4096 바이트 ㅇㅇ

리시버가 자신이 있는 버퍼의 크기를 리시브버퍼라하고, 세그먼트라 올라오면 버퍼에 채움. 이미 채워진 부분도 있음 아직 어플리케이션 못가고 ㅇㅇ

rwnd = rcvBuffer - [lastByteRcvd - LastByteRead] (그림 참고)

윈도우 사이즈의 최대는 rwnd보다 작거나 같음 -> 오버플로우가 안남

강의노트로 전체적인 흐름 참고
만약에 리시버에 rwnd가 늘어나면 알아서 센더한테 ack 를 보냄

---

flow control은 리시버가 주도해서 오버플로우 안나게 하는거고
리시버 버퍼에 남은 값을 ack에 넣어서 보내주고 센더가 그걸 보고 보내게 됨
