# application layer P2P

### CS model

1. 서버를 갖고있다
2. 모든 정보가 서버에 있어서 파일을 교환하는 것에 충분히 매니지 할 수 있음.
3. 서버를 중심으로 불법파일을 막을 수 있음. 제어 가능
4. 요청이 몰리면 성능이 저하되는 문제가 있음. 그래서 데이터 센터 기술이 적용됨
5. 항상 켜있고 ip 어드레스는 고정된다.
6. 클라이언트는 서버하고만 통신을 함. 바로 옆 클라이언트가 잇어도 직접 통신은 안됨
7. bottle-neck 문제가 있음. 요청이 몰리면 성능저하

### P2P

1. 서버가 없이 서로 연결하여 정보를 주고받음.
2. 모든 피어가 서버없이 클라이언트 서버 역할을 하기에 정보를 업로드 교환이 매우 쉬움
3. 중앙 관리 서버가 없어서 매니저블한 기능 제공에 한계가 있다.
4. 오버레이 네트웤을 갖고있음. 실질적으로 피지컬 링크로 연결이 되지만 어플리케이션 관점에서 피어들은 직접적으로 로지컬하게 연결을 맺어서 또 하나의 떠있는 네트웤의 특징을 만들어 낸다.

오버레이 네트워크 : 물리 네트워크 위에 성립되는 가상의 컴퓨터 네트워크.

피어들이 파일 완전체를 갖는게 아니라 조각(piece)을 갖고있음. 어떤 피어가 어떤 조각을 갖는지 암.
이후 내가 부족한 조각이 있다면 여러 피어에 요청을해서 조각을 받아옴. 그래서 클라서버 구조보다 빠름

CS모델은 피어가 증가할수록 걸리는 시간이 엄청 빠르게 증가함. p2p모델보다

## DHT(Distributed hash table)

p2p특징을 구현하는 가장 기본적인 방법론
p2p는 분산된 데이터 베이스라고 말할 수 있음. 파일을 찾기위한!
db라면 키(내가 찾으려는 컨텐츠 파일 이름)랑 벨류(컨텐츠 파일을 보유한 컴퓨터의 정보, ip어드레스, 포트넘버)가 있을거임.

오리지널 키는 너무 가변적이라 복잡하니까 키를 정형화하자! -> hash function.
key <- hash_function(original key) 일정한 길이를 갖는 값
해쉬함수는 유니폼해야함

## DHT

(키,벨류) 페어가 있음 키는 해쉬키 ㅇㅇ, 벨류는 여러 피어에 분산되있음
각 피어는 다른 피어에 대학 아주 작은 숫자(아이디)만 알고있음. 자기 다음 피어에 대한 정보만 알고있음.
네트워크에 키를 보내면 피어를 찾아서 그 피어가 벨류를 넘기는

특정 피어는 key를 가지고 쿼리를 날림. 그리고 해당하는 벨류값을 전달받음.

각 피어 p2p네트워크에 접속할때 유니크한 아이디를 받음. 어케 유니크하게 갖게 하는가. 각 피어는 랜덤하게 숫자가 들어감.
이렇게 나온 키랑 id는 n비트로 같음. 이 키밸류 페어는 아이디랑 가장 근접한 피어에 어사인함.

# 질문: 아무리 랜덤이라도 가능성이 있지 않나? 그리고 피어끼리는 어떤 아이디를 갖고있는지 모르니까 중복체크도 안되지 않나

어떤 피어가 있고 피어의 벨류는 아이피 어드레스 포트넘버 그런거임. 그리고 그 피어는 다른거랑 구분할 수있는 랜덤 아이디가 있음.
얘가 file aaa가 있으면 그걸 해쉬해서 해쉬키로 만듬. 그러면 아이디랑 키값의 비트사이즈가 같음. 이렇게 나온 페어가 갖고있는 파일의 정보는 파일에 대한 키값, 벨류는 이 피어의 밸류가 됨.

closest Id, 즉, 같거나 큰 다음 피어에 저장됨

피어 아이디끝에 도달하면 맨앞으로 돌아감

앞에서부터 뒤로 쭉쭉 돌리는거임수

찾을때는 찾는 피어랑 찾는 키를 돌리면서 키가 맞으면 그 피어에게 벨류값을 줌.그럼 벨류를 받아서 주인 피어에 연결해서 전송받음
그러면 전송받은 피어도 정보를 갖고있음. 근데 얘는 누구한테 정보를 알아온지 아니까 바로 중간 피어에 넘겨서 키 벨류를 넘겨서 어사인할 수 있음.

이렇게 피어가 쌓이면 한개에서 데이터를 가져오는게 아니라 분할해서 여러 피어에서 피스를 가져옴

# 질문 : 만약 검색할때 내 앞이 아닌ㄴ 뒤에 피어에 있으면 한바퀴를 도는건가?
